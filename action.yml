name: Firely.Terminal (GitHub Actions)
description: Run Firely.Terminal and the offical FHIR Java Validator in a GitHub Actions pipeline
inputs:
  PATH_TO_CONFORMANCE_RESOURCES:
    description: 'Relative paths of the folder(s) containing FHIR Conformance resources (StructureDefinition, ValueSet, CodeSystem)'
    required: true
  PATH_TO_EXAMPLES:
    description: 'Relative paths of the folder(s) containing examples for the FHIR Conformance resources defined by the project'
    required: false
  PATH_TO_QUALITY_CONTROL_RULES:
    description: 'Relative path pointing to Quality Control rules. Path MUST not include the .rules.yaml part of the file. Runs minimal.rules.yaml by default.'
    required: false
  DOTNET_VALIDATION_ENABLED:
    description: 'Boolean flag to run the .NET validator to validate conformance resources and examples'
    required: false
    default: true
  JAVA_VALIDATION_ENABLED:
    description: 'Boolean flag to run the offical HL7 Java validator to validate conformance resources and examples'
    required: false
    default: false
  EXPECTED_FAILS:
    description: 'Specify which steps in your validation workflow are expected to fail due to possible bugs in the validator(s). Allowed values: VALIDATION_CONFORMANCE_DOTNET, VALIDATION_CONFORMANCE_JAVA, VALIDATION_EXAMPLES_JAVA'
    required: false
  JAVA_VALIDATION_OPTIONS:
    description: 'Custom options passed to the Java validator. See https://confluence.hl7.org/display/FHIR/Using+the+FHIR+Validator'
    default: '-output-style compact'
    required: false
  SIMPLIFIER_USERNAME:
    description: 'Simplifier email address (not username), needed for running Quality Control checks. Please use GitHub Secrets for this variable.'
    required: true
  SIMPLIFIER_PASSWORD:
    description: 'Simplifier password, needed for running Quality Control checks. Please use GitHub Secrets for this variable.'
    required: true
  SUSHI_ENABLED:
    description: 'Boolean flag to run fsh-sushi on the current repository to generated conformance resources based on FHIR shorthand'
    required: false
    default: false
  SUSHI_OPTIONS:
    description: 'Custom options passed to SUSHI. See https://www.npmjs.com/package/fsh-sushi'
    required: false
  FIRELY_TERMINAL_VERSION:
    description: 'Version of Firely Terminal used for .NET-based validation'
    default: '3.3.2'
    required: true
  JAVA_VALIDATOR_VERSION:
    description: 'Version of org.hl7.fhir.core library used for Java-based validation'
    default: '6.5.2'
    required: true
  JAVA_VALIDATOR_DOWNLOAD_LOCATION:
    description: 'URL from which to download the Java validator JAR'
    default: 'https://github.com/hapifhir/org.hl7.fhir.core/releases/download/$JAVA_VALIDATOR_VERSION/validator_cli.jar'
  SUSHI_VERSION:
    description: 'Version of SUSHI used for compiling the FSH files'
    default: '3.13.1'
    required: true
  ZTS_ENABLED:
    descrption: 'Enables downloading packages from the central terminology server for Germany (https://terminologien.bfarm.de/fhirpackages.html)'
    default: true
    required: false
# Validate all resources using Firely Terminal 
runs:
  using: "composite"
  steps:
    # --------------------------------------------------------------------------------------------------- #
    #                                        FIRELY TERMINAL RESTORE                                      #
    # --------------------------------------------------------------------------------------------------- #

    # Firely.Terminal steps
    - name: Check if .NET is installed
      run: |
        if $INPUT_DOTNET_VALIDATION_ENABLED || $INPUT_SUSHI_ENABLED; then
          if ! command -v dotnet &> /dev/null
          then
              echo "dotnet could not be found. Please see actions/setup-dotnet to set it up before running this action."
              exit 1
          fi
        fi
      shell: bash
      env:
        INPUT_DOTNET_VALIDATION_ENABLED: ${{ inputs.DOTNET_VALIDATION_ENABLED }}
        INPUT_SUSHI_ENABLED: ${{ inputs.SUSHI_ENABLED }}
    # Test Firely SDK version
    - name: Check .NET SDK Version
      run: |
        if $INPUT_DOTNET_VALIDATION_ENABLED || $INPUT_SUSHI_ENABLED; then
          CHECK_DOTNET_VERSION=$(dotnet --version)
          echo "DOTNET_VERSION: $CHECK_DOTNET_VERSION"
        fi
      shell: bash
      env:
        INPUT_DOTNET_VALIDATION_ENABLED: ${{ inputs.DOTNET_VALIDATION_ENABLED }}
        INPUT_SUSHI_ENABLED: ${{ inputs.SUSHI_ENABLED }}
    # Install Firely.Terminal
    - name: Install Firely.Terminal
      run: |
        if $INPUT_DOTNET_VALIDATION_ENABLED || $INPUT_SUSHI_ENABLED; then
          if ! command -v fhir &> /dev/null
          then
            dotnet tool install --global Firely.Terminal --version $FIRELY_TERMINAL_VERSION > /dev/null
          fi
        fi
      shell: bash
      env:
        FIRELY_TERMINAL_VERSION: ${{ inputs.FIRELY_TERMINAL_VERSION }}
        INPUT_DOTNET_VALIDATION_ENABLED: ${{ inputs.DOTNET_VALIDATION_ENABLED }}
        INPUT_SUSHI_ENABLED: ${{ inputs.SUSHI_ENABLED }}
    # Test Firely.Terminal install
    - name: Check Firely Terminal Version
      run: |
        if $INPUT_DOTNET_VALIDATION_ENABLED || $INPUT_SUSHI_ENABLED; then
         CHECK_FIRELY_TERMINAL_VERSION=$(fhir -v | tr '\n' ' ') # Print everything in a single line
          echo "FIRELY_TERMINAL_VERSION: $CHECK_FIRELY_TERMINAL_VERSION"
        fi
      shell: bash
      env:
        INPUT_DOTNET_VALIDATION_ENABLED: ${{ inputs.DOTNET_VALIDATION_ENABLED }}
        INPUT_SUSHI_ENABLED: ${{ inputs.SUSHI_ENABLED }}
    # Simplifier Login
    - name: Simplifier login
      run: |
        if $INPUT_DOTNET_VALIDATION_ENABLED || $INPUT_SUSHI_ENABLED; then
         fhir login email=$INPUT_SIMPLIFIER_USERNAME password=$INPUT_SIMPLIFIER_PASSWORD
        fi
      shell: bash
      env:
        INPUT_DOTNET_VALIDATION_ENABLED: ${{ inputs.DOTNET_VALIDATION_ENABLED }}
        INPUT_SUSHI_ENABLED: ${{ inputs.SUSHI_ENABLED }}
        INPUT_SIMPLIFIER_USERNAME: ${{ inputs.SIMPLIFIER_USERNAME }}
        INPUT_SIMPLIFIER_PASSWORD: ${{ inputs.SIMPLIFIER_PASSWORD }}
    # Restore all dependencies listed in the package.json file (need to be on the root level)
    - name: FHIR Dependency restore
      run: "if $INPUT_DOTNET_VALIDATION_ENABLED || $INPUT_SUSHI_ENABLED; then\n  if [ ! -f \"package.json\" ]; then\n    echo \"package.json does not exist. Please add it to the root folder and add all project dependencies.\"\n    exit 1\n  fi\n  \n  fhirVersions=(\"3.0.2\" \"4.0.1\" \"4.1.0\" \"4.6.0\")\n  for fhirVersion in ${fhirVersions[@]}; do\n    fhirVersionFoundInPackageJson=$(cat package.json | jq '.fhirVersions | index('\\\"$fhirVersion\\\"')')\n    if [[ ! \"$fhirVersionFoundInPackageJson\" = null ]]; then\n      echo \"Found FHIR version $fhirVersion in package.json\"\n      if [[ \"$fhirVersion\" = \"3.0.2\" ]]; then\n        fhir spec R3\n        break\n      elif [[ \"$fhirVersion\" = \"4.0.1\" ]]; then\n        fhir spec R4\n        break\n      elif [[ \"$fhirVersion\" = \"4.1.0\" ]]; then\n        fhir spec R4B\n        break\n      elif [[ \"$fhirVersion\" = \"4.6.0\" ]]; then\n        fhir spec R5\n        break\n      else\n        echo \"This FHIR version is currently not supported.\";\n        exit 1\n      fi\n    fi\n  done\n\n  echo \"Attempting to restore package dependencies based on package.json ...\"\n  FHIR_RESTORE=$((fhir restore | tr '\\n' ' ')|| true)  # Print everything in a single line\n  if [[ \"$FHIR_RESTORE\" == *\"Cannot restore\"* ]]; then\n    echo $FHIR_RESTORE\n    exit 1\n  fi\n  echo \"Restore of package.json was successful: $FHIR_RESTORE\"\nfi\n"
      shell: bash
      env:
        INPUT_DOTNET_VALIDATION_ENABLED: ${{ inputs.DOTNET_VALIDATION_ENABLED }}
        INPUT_SUSHI_ENABLED: ${{ inputs.SUSHI_ENABLED }}
    # ZTS (Central Terminology Server for Germany, terminologien.bfarm.de) package loading
    - name: ZTS Package dependency restore
      run: "if $INPUT_ZTS_ENABLED; then\n  ztsDependencies=$(jq -r '.[\"zts-dependencies\"] | keys[]?' package.json)\n  if [[ -n \"$ztsDependencies\" ]]; then\n    packagesForZtsToken=$(echo \"$ztsDependencies\" | jq -R . | jq -s '{packages: .}')\n  \n    ztsTokenResponse=$(curl -s -w \"\\n%{http_code}\" \\\n      -X POST https://terminologien.bfarm.de/api/generate-token \\\n      -H \"Content-Type: application/json\" \\\n      -d \"$packagesForZtsToken\")\n\n    ztsTokenResponseBody=$(echo \"$ztsTokenResponse\" | sed '$d')\n    ztsTokenResponseCode=$(echo \"$ztsTokenResponse\" | tail -n 1)\n\n    if [[ \"$ztsTokenResponseCode\" == 2* ]]; then\n        ztsAccessToken=$(echo \"$ztsTokenResponseBody\" | jq -r '.token')\n        if [[ \"$ztsAccessToken\" != \"null\" ]]; then\n          echo \"Successfully retrieved a token for the ZTS to do download the terminology packgages. Response code: $ztsTokenResponseCode\"\n        else\n          echo \"Failed to retrieve a token for the ZTS to download the terminology packages. No token found in response.\"\n          exit 1\n        fi\n    else\n        echo \"Failed to retrieve a token for the ZTS to download the terminology packages. Response code: $ztsTokenResponseCode\"\n        echo \"Response body: $ztsTokenResponseBody\"\n        exit 1\n    fi\n\n    ztsDependencyPairs=$(jq -r '.[\"zts-dependencies\"] | to_entries[] | \"\\(.key)=\\(.value)\"' package.json)\n    for ztsDependencyPair in $ztsDependencyPairs; do\n      packageName=${ztsDependencyPair%=*}\n      packageVersion=${ztsDependencyPair#*=}\n      echo \"Trying to install terminology package '$packageName' in version '$packageVersion' from ZTS registry\"\n      \n      packageFile=\"${packageName}-${packageVersion}.tgz\"\n      packageDownloadResponseCode=$(curl -H \"Authorization: Bearer $ztsAccessToken\" \\\n        https://terminologien.bfarm.de/packages/$packageName/$packageVersion \\\n        -s -o \"$packageFile\" -w \"%{http_code}\")\n        \n      if [[ \"$packageDownloadResponseCode\" == 2* && -s \"$packageFile\" ]]; then\n        fhirCacheLocation=$(fhir cache location --path)\n        fhirPackageCacheDest=\"${fhirCacheLocation}/${packageName}#${packageVersion}\"\n        mkdir -p $fhirPackageCacheDest\n        tar -xzf $packageFile -C $fhirPackageCacheDest\n\n        if [[ ! -d \"$fhirPackageCacheDest\" ]]; then\n          echo \"Error: Failed to move $extractedFolderForPackage to $fhirPackageCacheDest\"\n          exit 1\n        fi\n\n        echo \"Successfully installed terminology package '$packageName' in version '$packageVersion' from ZTS registry\"\n        \n      else\n        echo \"Failed to download terminology package '$packageName' in version '$packageVersion'.\"\n        [[ -e \"$packageFile\" ]] && rm \"$packageFile\"\n        exit 1\n      fi\n    done\n  \n  fi\nfi\n"
      shell: bash
      env:
        INPUT_ZTS_ENABLED: ${{ inputs.ZTS_ENABLED }}
    # --------------------------------------------------------------------------------------------------- #
    #                                                 SUSHI                                               #
    # --------------------------------------------------------------------------------------------------- #
    - name: Check if npm is installed
      run: |
        if $INPUT_SUSHI_ENABLED; then
          if ! command -v npm &> /dev/null
          then
              echo "npm could not be found. Please see actions/setup-node to set it up before running this action."
              exit 1
          fi
        fi
      shell: bash
      env:
        INPUT_SUSHI_ENABLED: ${{ inputs.SUSHI_ENABLED }}
    - name: Check npm Version
      run: |
        if $INPUT_SUSHI_ENABLED; then
          CHECK_NPM_VERSION=$(npm --version)
          echo "NPM_VERSION: $CHECK_NPM_VERSION"
        fi
      shell: bash
      env:
        INPUT_SUSHI_ENABLED: ${{ inputs.SUSHI_ENABLED }}
    - name: Install fsh-sushi
      run: |
        if $INPUT_SUSHI_ENABLED; then
          sudo chown -R $USER /usr/local/lib/node_modules
          sudo npm install -g fsh-sushi@$SUSHI_VERSION
        fi
      shell: bash
      env:
        SUSHI_VERSION: ${{ inputs.SUSHI_VERSION }}
        INPUT_SUSHI_ENABLED: ${{ inputs.SUSHI_ENABLED }}
    - name: Check SUSHI version
      run: |
        if $INPUT_SUSHI_ENABLED; then
          sushi -v
        fi
      shell: bash
      env:
        INPUT_SUSHI_ENABLED: ${{ inputs.SUSHI_ENABLED }}
    - name: Generate conformance resources with SUSHI
      run: |
        if $INPUT_SUSHI_ENABLED; then
          sushi $INPUT_SUSHI_OPTIONS
        fi
      shell: bash
      env:
        INPUT_SUSHI_ENABLED: ${{ inputs.SUSHI_ENABLED }}
        INPUT_SUSHI_OPTIONS: ${{ inputs.SUSHI_OPTIONS }}
    # --------------------------------------------------------------------------------------------------- #
    #                                            .NET VALIDATOR                                           #
    # --------------------------------------------------------------------------------------------------- #

    # Run Quality Control checks incl. validation
    - name: Run Quality Control checks
      run: |
        if $INPUT_DOTNET_VALIDATION_ENABLED; then
          echo "Running quality control checks incl. validation based on Firely Terminal ..."
          if echo $INPUT_EXPECTED_FAILS | grep -w -q VALIDATION_CONFORMANCE_DOTNET; then
            fhir check $INPUT_PATH_TO_QUALITY_CONTROL_RULES
          else
            fhir check --fail $INPUT_PATH_TO_QUALITY_CONTROL_RULES
          fi
        fi
      shell: bash
      env:
        INPUT_EXPECTED_FAILS: ${{ inputs.EXPECTED_FAILS }}
        INPUT_DOTNET_VALIDATION_ENABLED: ${{ inputs.DOTNET_VALIDATION_ENABLED }}
        INPUT_PATH_TO_QUALITY_CONTROL_RULES: ${{ inputs.PATH_TO_QUALITY_CONTROL_RULES }}
    - name: Report Success - .NET Validator
      run: |
        if $INPUT_DOTNET_VALIDATION_ENABLED; then
          echo "Finished validation using .NET validator (Conformance resources) ..."
        fi
      shell: bash
      env:
        INPUT_DOTNET_VALIDATION_ENABLED: ${{ inputs.DOTNET_VALIDATION_ENABLED }}
    #Examples are currently not used as Firely Terminal can't differentiate between these two in QC checks.

    # --------------------------------------------------------------------------------------------------- #
    #                                            JAVA Validator                                           #
    # --------------------------------------------------------------------------------------------------- #

    # Offical HL7 Java validator steps
    - name: Check if Java is installed
      run: |
        if $INPUT_JAVA_VALIDATION_ENABLED; then
          if ! command -v java &> /dev/null
          then
              echo "java could not be found. Please see actions/setup-java to set it up before running this action."
              exit 1
          fi
        fi
      shell: bash
      env:
        INPUT_JAVA_VALIDATION_ENABLED: ${{ inputs.JAVA_VALIDATION_ENABLED }}
    - name: Download Java Validator
      run: "if $INPUT_JAVA_VALIDATION_ENABLED; then\n  CHECK_JAVA_VERSION=$(java -version 2>&1 | head -1 | cut -d'\"' -f2)\n  echo \"JAVA_VERSION: $CHECK_JAVA_VERSION\"\n  echo \"JAVA_VALIDATOR_VERSION: $JAVA_VALIDATOR_VERSION\"\n  JAVA_VALIDATOR_DOWNLOAD_LOCATION=$(eval echo \"$JAVA_VALIDATOR_DOWNLOAD_LOCATION\")\n  echo \"JAVA_VALIDATOR_DOWNLOAD_LOCATION: $JAVA_VALIDATOR_DOWNLOAD_LOCATION\"\n  \n  wget -q $JAVA_VALIDATOR_DOWNLOAD_LOCATION -O validator_cli.jar\nfi\n"
      shell: bash
      env:
        JAVA_VALIDATOR_VERSION: ${{ inputs.JAVA_VALIDATOR_VERSION }}
        JAVA_VALIDATOR_DOWNLOAD_LOCATION: ${{ inputs.JAVA_VALIDATOR_DOWNLOAD_LOCATION }}
        INPUT_JAVA_VALIDATION_ENABLED: ${{ inputs.JAVA_VALIDATION_ENABLED }}
    - name: Install jq
      run: "if $INPUT_JAVA_VALIDATION_ENABLED; then \n  sudo apt-get update > /dev/null\n  sudo apt-get install --no-install-recommends -y jq findutils curl ca-certificates > /dev/null\nfi\n"
      shell: bash
      env:
        INPUT_JAVA_VALIDATION_ENABLED: ${{ inputs.JAVA_VALIDATION_ENABLED }}
    - name: Validate all conformance resources in scope of the repository
      run: "\n# Define color codes\nERROR=$'\\033[0;31m'\nWARN=$'\\033[0;33m'\nINFO=$'\\033[0;34m'\nOK=$'\\033[0;32m'\nNC=$'\\033[0m'\n      \nif $INPUT_JAVA_VALIDATION_ENABLED; then\n  echo \"Starting validation using Java validator (Conformance resources) ...\"\n  IG_DEPENDENCIES=$(jq -r '(.dependencies + .[\"zts-dependencies\"]) | to_entries | map(\"-ig \" + .key + \"#\" + .value) | join(\" \")' package.json)\n  echo \"IG_DEPENDENCIES: $IG_DEPENDENCIES\"\n  \n  for p in $INPUT_PATH_TO_CONFORMANCE_RESOURCES; # Get combined path to conformance resources, we want to provide all other directories as context for the current validation\n  do  \n    LOCAL_IG_PARAMETERS+=\"-ig $GITHUB_WORKSPACE/$p \"\n  done\n  \n  for p in $INPUT_PATH_TO_CONFORMANCE_RESOURCES; \n  do\n  \n    # Ensure directory ends with \"/\"\n    if [[ ! \"$p\" =~ .*/$ ]]; then\n      p=\"$p/\"\n    fi\n    \n    UNESCPAED_IG_DEPENDENCIES=$(echo $IG_DEPENDENCIES | tr -d '\"')\n    \n    if echo $INPUT_EXPECTED_FAILS | grep -w -q VALIDATION_CONFORMANCE_JAVA; then\n      javaValidatorOutput=$(java -jar validator_cli.jar $GITHUB_WORKSPACE/$p*.xml $GITHUB_WORKSPACE/$p*.json -version $FHIR_VERSION $INPUT_JAVA_VALIDATION_OPTIONS $UNESCPAED_IG_DEPENDENCIES $LOCAL_IG_PARAMETERS|| true)\n    else\n      javaValidatorOutput=$(java -jar validator_cli.jar $GITHUB_WORKSPACE/$p*.xml $GITHUB_WORKSPACE/$p*.json -version $FHIR_VERSION $INPUT_JAVA_VALIDATION_OPTIONS $UNESCPAED_IG_DEPENDENCIES $LOCAL_IG_PARAMETERS)\n    fi\n\n    javaValidatorOutput=$(echo \"$javaValidatorOutput\" | sed -E \"\n      s/(:[[:space:]]*)Error([[:space:]]+-)/\\1${ERROR}Error${NC}\\2/g;\n      s/(:[[:space:]]*)Warning([[:space:]]+-)/\\1${WARN}Warning${NC}\\2/g;\n      s/(:[[:space:]]*)Information([[:space:]]+-)/\\1${INFO}Information${NC}\\2/g;\n      s/(-[[:space:]]+)All OK/\\1${OK}All OK${NC}/g\n    \")\n\n    echo -e \"$javaValidatorOutput\"\n    \n  done\nfi\necho \"Finished validation using Java validator (Conformance resources) ...\"\n"
      shell: bash
      env:
        FHIR_VERSION: "4.0"
        INPUT_PATH_TO_CONFORMANCE_RESOURCES: ${{ inputs.PATH_TO_CONFORMANCE_RESOURCES }}
        INPUT_JAVA_VALIDATION_ENABLED: ${{ inputs.JAVA_VALIDATION_ENABLED }}
        INPUT_EXPECTED_FAILS: ${{ inputs.EXPECTED_FAILS }}
        INPUT_JAVA_VALIDATION_OPTIONS: ${{ inputs.JAVA_VALIDATION_OPTIONS }}
    - name: Validate all example resources in scope of the repository
      run: "\n# Define color codes\nERROR=$'\\033[0;31m'\nWARN=$'\\033[0;33m'\nINFO=$'\\033[0;34m'\nOK=$'\\033[0;32m'\nNC=$'\\033[0m'\n\nif $INPUT_JAVA_VALIDATION_ENABLED; then\n  IG_DEPENDENCIES=$(jq -r '(.dependencies + .[\"zts-dependencies\"]) | to_entries | map(\"-ig \" + .key + \"#\" + .value) | join(\" \")' package.json)\n  for p in $INPUT_PATH_TO_CONFORMANCE_RESOURCES; # Get combined path to conformance resources, we want to validate against the current version of the conformance resources\n  do  \n    COMBINED_IG_PARAMETERS+=\"-ig $GITHUB_WORKSPACE/$p \"\n  done\n  \n  for p in $PATH_TO_EXAMPLES; \n  do\n    \n    # Ensure directory ends with \"/\"\n    if [[ ! \"$p\" =~ .*/$ ]]; then\n      p=\"$p/\"\n    fi\n  \n    UNESCPAED_IG_DEPENDENCIES=$(echo $IG_DEPENDENCIES | tr -d '\"')\n    \n    if echo $INPUT_EXPECTED_FAILS | grep -w -q VALIDATION_EXAMPLES_JAVA; then\n      javaValidatorOutput=$(java -jar validator_cli.jar $GITHUB_WORKSPACE/$p*.xml $GITHUB_WORKSPACE/$p*.json -version $FHIR_VERSION $INPUT_JAVA_VALIDATION_OPTIONS $UNESCPAED_IG_DEPENDENCIES $COMBINED_IG_PARAMETERS || true)\n    else\n      javaValidatorOutput=$(java -jar validator_cli.jar $GITHUB_WORKSPACE/$p*.xml $GITHUB_WORKSPACE/$p*.json -version $FHIR_VERSION $INPUT_JAVA_VALIDATION_OPTIONS $UNESCPAED_IG_DEPENDENCIES $COMBINED_IG_PARAMETERS)\n    fi\n\n    javaValidatorOutput=$(echo \"$javaValidatorOutput\" | sed -E \"\n      s/(:[[:space:]]*)Error([[:space:]]+-)/\\1${ERROR}Error${NC}\\2/g;\n      s/(:[[:space:]]*)Warning([[:space:]]+-)/\\1${WARN}Warning${NC}\\2/g;\n      s/(:[[:space:]]*)Information([[:space:]]+-)/\\1${INFO}Information${NC}\\2/g;\n      s/(-[[:space:]]+)All OK/\\1${OK}All OK${NC}/g\n    \")\n    echo -e \"$javaValidatorOutput\"\n    \n  done\nfi\n"
      shell: bash
      env:
        INPUT_PATH_TO_CONFORMANCE_RESOURCES: ${{ inputs.PATH_TO_CONFORMANCE_RESOURCES }}
        PATH_TO_EXAMPLES: ${{ inputs.PATH_TO_EXAMPLES }}
        FHIR_VERSION: "4.0"
        INPUT_JAVA_VALIDATION_ENABLED: ${{ inputs.JAVA_VALIDATION_ENABLED }}
        INPUT_EXPECTED_FAILS: ${{ inputs.EXPECTED_FAILS }}
        INPUT_JAVA_VALIDATION_OPTIONS: ${{ inputs.JAVA_VALIDATION_OPTIONS }}
